#!/usr/bin/env python3
"""
Development API Server
A standalone Python server for local development that bypasses Windows process isolation issues

Usage:
1. Run directly in your terminal: python development_api_server.py
2. Or use your IDE's integrated terminal
3. Access at http://localhost:8007
"""

import asyncio
import json
import time
import sys
import os
from datetime import datetime
from typing import Dict, Any, Optional

from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import uvicorn

# Request/Response Models
class ChatRequest(BaseModel):
    message: str
    model: Optional[str] = "development-model"
    temperature: Optional[float] = 0.7
    max_tokens: Optional[int] = 1000

class ChatResponse(BaseModel):
    response: str
    model: str
    timestamp: float
    processing_time: float

# Create FastAPI app
app = FastAPI(
    title="SentientCore Development API",
    description="Local development server for SentientCore API endpoints",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global state for development
server_start_time = time.time()
request_count = 0

@app.middleware("http")
async def request_logging_middleware(request: Request, call_next):
    """Log all requests for development"""
    global request_count
    request_count += 1
    
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {request.method} {request.url.path} - {response.status_code} ({process_time:.3f}s)")
    
    return response

# Root endpoint
@app.get("/")
async def read_root():
    """Root endpoint with server information"""
    uptime = time.time() - server_start_time
    return {
        "message": "SentientCore Development API Server",
        "status": "running",
        "version": "1.0.0",
        "uptime_seconds": round(uptime, 2),
        "requests_served": request_count,
        "timestamp": time.time(),
        "endpoints": {
            "health": "/health",
            "chat": "/api/chat/message/json",
            "docs": "/docs",
            "redoc": "/redoc"
        }
    }

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": time.time(),
        "uptime": time.time() - server_start_time,
        "requests_served": request_count,
        "python_version": sys.version.split()[0],
        "platform": sys.platform
    }

# Chat endpoint (GET) - for simple testing
@app.get("/api/chat/message/json")
async def chat_get():
    """GET chat endpoint for testing"""
    return {
        "response": "Hello! This is a test response from the development server.",
        "model": "development-model",
        "timestamp": time.time(),
        "method": "GET",
        "note": "Use POST for actual chat interactions"
    }

# Chat endpoint (POST) - main chat functionality
@app.post("/api/chat/message/json", response_model=ChatResponse)
async def chat_post(request: ChatRequest):
    """POST chat endpoint - simulates AI chat functionality"""
    start_time = time.time()
    
    # Simulate processing time
    await asyncio.sleep(0.1)
    
    # Generate a mock response based on the input
    mock_responses = [
        f"I understand you said: '{request.message}'. This is a development server response.",
        f"Thank you for your message: '{request.message}'. I'm a mock AI assistant running in development mode.",
        f"Processing your request: '{request.message}'. This response is generated by the development server.",
        f"Hello! You asked about: '{request.message}'. This is a simulated response for testing purposes."
    ]
    
    # Select response based on message hash for consistency
    response_index = hash(request.message) % len(mock_responses)
    mock_response = mock_responses[response_index]
    
    processing_time = time.time() - start_time
    
    return ChatResponse(
        response=mock_response,
        model=request.model or "development-model",
        timestamp=time.time(),
        processing_time=processing_time
    )

# Additional development endpoints
@app.get("/api/status")
async def api_status():
    """API status endpoint"""
    return {
        "api_version": "1.0.0",
        "server_status": "running",
        "features": {
            "chat": True,
            "health_check": True,
            "cors_enabled": True,
            "request_logging": True
        },
        "statistics": {
            "uptime": time.time() - server_start_time,
            "requests_served": request_count,
            "average_requests_per_minute": request_count / max((time.time() - server_start_time) / 60, 1)
        }
    }

@app.get("/api/test")
async def test_endpoint():
    """Test endpoint with sample data"""
    return {
        "test": "success",
        "timestamp": time.time(),
        "sample_data": {
            "numbers": list(range(1, 11)),
            "strings": ["hello", "world", "test"],
            "nested": {
                "level1": {
                    "level2": "deep_value"
                }
            }
        },
        "server_info": {
            "python": sys.version.split()[0],
            "platform": sys.platform,
            "pid": os.getpid()
        }
    }

# Error handlers
@app.exception_handler(404)
async def not_found_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=404,
        content={
            "error": "Not Found",
            "message": f"The endpoint {request.url.path} was not found",
            "available_endpoints": [
                "/",
                "/health",
                "/api/chat/message/json",
                "/api/status",
                "/api/test",
                "/docs",
                "/redoc"
            ],
            "timestamp": time.time()
        }
    )

@app.exception_handler(500)
async def internal_error_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred",
            "timestamp": time.time()
        }
    )

def main():
    """Main function to run the development server"""
    print("=" * 70)
    print("üöÄ SENTIENTCORE DEVELOPMENT API SERVER")
    print("=" * 70)
    print(f"üìÖ Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üêç Python: {sys.version.split()[0]}")
    print(f"üíª Platform: {sys.platform}")
    print(f"üìÅ Working Directory: {os.getcwd()}")
    print()
    print("üì° Server will be available at:")
    print("   ‚Ä¢ http://localhost:8008")
    print("   ‚Ä¢ http://127.0.0.1:8008")
    print()
    print("üìö Available endpoints:")
    print("   ‚Ä¢ GET  /              - Server information")
    print("   ‚Ä¢ GET  /health        - Health check")
    print("   ‚Ä¢ GET  /api/chat/message/json - Test chat (GET)")
    print("   ‚Ä¢ POST /api/chat/message/json - Chat endpoint")
    print("   ‚Ä¢ GET  /api/status    - API status")
    print("   ‚Ä¢ GET  /api/test      - Test endpoint")
    print("   ‚Ä¢ GET  /docs          - API documentation")
    print("   ‚Ä¢ GET  /redoc         - ReDoc documentation")
    print()
    print("‚ö° Features:")
    print("   ‚Ä¢ CORS enabled for all origins")
    print("   ‚Ä¢ Request logging with timestamps")
    print("   ‚Ä¢ Mock AI chat responses")
    print("   ‚Ä¢ Interactive API documentation")
    print()
    print("üõë Press Ctrl+C to stop the server")
    print("=" * 70)
    print()
    
    # Run the server
    try:
        uvicorn.run(
            app,
            host="127.0.0.1",  # Bind to localhost only for security
            port=8008,
            log_level="info",
            access_log=False,  # We have custom logging
            reload=False,
            workers=1
        )
    except KeyboardInterrupt:
        print("\nüõë Server stopped by user")
    except Exception as e:
        print(f"\n‚ùå Server error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("\nüëã Development server shutdown complete")

if __name__ == "__main__":
    main()